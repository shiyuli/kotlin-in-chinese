<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
  <head>
    <title>代理模式</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta content="" name="description"/>
    <meta content="GitBook 3.2.2" name="generator"/>
    <meta content="huanglizhuo" name="author"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
        
<div class="page">
    
        <h1 class="book-chapter" id="calibre_toc_22">代理模式</h1>
        <div class="section">
            <h2 id="代理" class="calibre10">代理</h2>
<h3 id="类代理" class="calibre16">类代理</h3>
<p class="calibre6"><a href="https://en.wikipedia.org/wiki/Delegation_pattern" target="_blank" class="calibre7 pcalibre2 pcalibre pcalibre1">代理模式</a> 给实现继承提供了很好的代替方式， Kotlin 在语法上支持这一点，所以并不需要什么样板代码。<code class="calibre19 pcalibre6 pcalibre5">Derived</code> 类可以继承 <code class="calibre19 pcalibre6 pcalibre5">Base</code> 接口并且指定一个对象代理它全部的公共方法：</p>
<pre class="calibre17"><code class="lang-kotlin pcalibre4 pcalibre3">interface Base {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-comment">print</span><span class="hljs-params">()</span></span>
}

<span class="hljs-type"><span class="hljs-keyword">class</span> <span class="hljs-comment">BaseImpl</span></span>(<span class="hljs-variable"><span class="hljs-keyword">val</span> x</span>: <span class="hljs-keyword">Int</span>) : Base {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-comment">print</span><span class="hljs-params">()</span> { <span class="hljs-comment">printz</span><span class="hljs-params">(x)</span> }</span>
}

<span class="hljs-type"><span class="hljs-keyword">class</span> <span class="hljs-comment">Derived</span></span>(b: Base) : Base by b

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-comment">main</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-variable"><span class="hljs-keyword">val</span> b</span> = BaseImpl(<span class="hljs-params">10</span>)
    Derived(b).print()
}
</code></pre>
<p class="calibre6">在 <code class="calibre19 pcalibre6 pcalibre5">Derived</code> 的父类列表中的 by 从句会将 <code class="calibre19 pcalibre6 pcalibre5">b</code> 存储在 <code class="calibre19 pcalibre6 pcalibre5">Derived</code> 内部对象，并且编译器会生成 <code class="calibre19 pcalibre6 pcalibre5">Base</code> 的所有方法并转给 <code class="calibre19 pcalibre6 pcalibre5">b</code>。</p>

        </div>
    
</div>

        
    


</body></html>
